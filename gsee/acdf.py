import numpy as np
from gsee import helpers
from gsee import quantum_circuits
from gsee import samplers



def acdf_kernel(max_dft_order, dft_filter_coeffs, dft_orders_sample, hamiltonian_evolutors_sample, 
                energy_grid=None, nmesh=2000):
    """
    Evaluate ACDF given Fj, j_sample, Z_sample
    Args:
        max_dft_order                : cutoff of the DFT expansion (d in the paper)
        dft_coeffs_filter            : Fourier transforms of the filter function (here the filter function is Heaviside) (Fj in the paper)
        dft_orders_sample            : a sample of integers in [-max_dft_order, max_dft_order], generated by classical sampling
        hamiltonian_evolutors_sample : a sample of complex numbers in {+-1 +- 1.j}, generated by the quantum computer (Z_J in the paper)
        energy_grid                  : points where the function is evaluated (x in the paper)
        nmesh                        : number of grids to generate a mesh of real space points
    Returns:
        An array containing the values of the approximate CDF at points in energy_grid.
    """
    

    num_samples = len(dft_orders_sample)
    angle_dft_coeffs = np.angle(dft_filter_coeffs)

    # generate 
    if energy_grid is None:
        energy_grid = np.linspace(-np.pi, np.pi, nmesh, endpoint=True)
    try:
        num_grid = energy_grid.shape[-1]
        acdf_sample = np.zeros(num_grid, dtype=np.complex)
    except: 
        num_grid = 1
        acdf_sample = 0.j

    for i in range(num_samples): # TODO use numpy.einsum to get rid of the loop
        dft_order, hamiltonian_evolutor = dft_orders_sample[i], hamiltonian_evolutors_sample[i]
        angle = angle_dft_coeffs[dft_order + max_dft_order]
        acdf_single_sample = eval_acdf_single_sample(energy_grid, dft_order, hamiltonian_evolutor, angle)
        acdf_sample += acdf_single_sample

    abs_dft_coeffs = np.abs(dft_filter_coeffs)
    F_tot = np.sum(abs_dft_coeffs)

    acdf_sample = acdf_sample * F_tot / num_samples

    return acdf_sample


def classical_sampler(num_samples, max_dft_order, rescaled_energy_acc, nmesh=2000):
    """
    Generate the dft orders from [-max_dft_order, max_dft_order] wrt the heaviside distribution.
    Args:
        num_samples         : number of samples
        max_dft_order       : cutoff of the DFT expansion (d in the paper)
        rescaled_energy_acc : energy accuracy * tau (delta in the paper)
        nmesh               : number of grids to generate a mesh of real space points
    Returns:
        dft_coeffs          : an array of complex numbers (DFT coefficients of the approximate Heaviside function)
        dft_orders_sample   : an array of integers of size num_samples.
    """

    # TODO this function is unnecessary
    dft_order_range = np.arange(-max_dft_order, max_dft_order+1, 1)
    # generate Fj Pr(k = j) = |Fj| / \sum_j |Fj|
    dft_coeffs = helpers.dft_coeffs_approx_heaviside(
        max_dft_order, rescaled_energy_acc, dft_order_range, nmesh
    )

    dft_orders_sample = samplers.dft_order_sampler(num_samples, max_dft_order, dft_coeffs)

    return dft_coeffs, dft_orders_sample


def quantum_sampler(dft_orders_sample, input_state_vector, hamiltonian, energy_rescalor=None, spectrum_bound=np.pi/3):
    """
    Sampling <exp[-i j tau H]>.
    Args:
        dft_order_sample : a sample of integers in [-max_dft_order, max_dft_order], generated by classical sampling
        input_state_vector: initial state
        hamiltonian: Hamiltonian
        energy_rescalor: rescaling factor of the Hamiltonian (tau in the paper)
    Returns:
        expiH_sample - array of complex numbers, set of (XJ + iYJ) values.
    """

    return samplers.hamiltonian_evolutor_sampler(dft_orders_sample, 
                                                 input_state_vector, 
                                                 hamiltonian, 
                                                 energy_rescalor=energy_rescalor, 
                                                 spectrum_bound=spectrum_bound)


def eval_acdf_single_sample(energy_grids, dft_order, hamiltonian_evolutor, angle_dft_coeff):
    """
    Evaluate an unbiased estimation of the ACDF at energy grids (Eq. 14 in the paper).
        G = F_tot * (Z_j) * exp[i (ang_j + j * x)]
    We omit F_tot here and multiply it at the end.
    Args:
        energy_grids         : points at which the function is evaluated (x in the paper).
        dft_order            : int (J in the paper)
        hamiltonian_evolutor : a complex number that can be {+- 1 +- 1j} (Z_J in the paper)
        angle_dft_coeff      : the angle of the DFT coefficient of order dft_order (theta_J in the paper)
    Returns:
        1D array of the size of x.
    """
    acdf_single_estimate = hamiltonian_evolutor * np.exp(1.0j * (angle_dft_coeff + dft_order * energy_grids))
    return acdf_single_estimate

