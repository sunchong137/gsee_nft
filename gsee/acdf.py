import numpy as np
from gsee import helpers
from gsee import quantum_circuits


def classical_sampler(num_samples, max_dft_order, rescaled_energy_acc, nmesh=2000):
    """
    Generate the dft orders from [-max_dft_order, max_dft_order]
    Args:
        num_samples         : number of samples
        max_dft_order       : cutoff of the DFT expansion (d in the paper)
        rescaled_energy_acc : energy accuracy * tau (delta in the paper)
        nmesh               : number of grids to generate a mesh of real space points
    Returns:
        dft_coeffs          : - an array of complex numbers (DFT coefficients of the approximate Heaviside function)
        dft_orders_samp - an array of integers of size num_samples.
    """

    # generate Fj Pr(k = j) = |Fj| / \sum_j |Fj|
    dft_order_range = np.arange(-max_dft_order, max_dft_order+1, 1)
    dft_coeffs = helpers.dft_coeffs_approx_heaviside(
        max_dft_order, rescaled_energy_acc, dft_order_range, nmesh
    )
    dft_coeffs_abs = np.abs(dft_coeffs)

    # evaluate probability distribution Pr(J = j) = |Fj| / \sum_j |Fj|
    coeffs_tot = np.sum(dft_coeffs_abs)
    weights = dft_coeffs_abs / coeffs_tot

    # generate random j values
    dft_orders_sample = np.random.choice(dft_order_range, size=num_samples, p=weights)

    return dft_coeffs, dft_orders_sample


def quantum_sampler(dft_order_sample, input_state_vector, hamiltonian, energy_rescalor=None):
    """
    Sampling <exp[-i j tau H]>.
    Args:
        dft_order_sample : a sample of integers in [-max_dft_order, max_dft_order], generated by classical sampling
        input_state_vector: initial state
        hamiltonian: Hamiltonian
        energy_rescalor: rescaling factor of the Hamiltonian (tau in the paper)
    Returns:
        expiH_sample - array of complex numbers, set of (XJ + iYJ) values.
    """

    # generate Xj and Yj values
    real_sample = [] # real part of <exp[-i j tau H]>
    imag_sample = [] # imaginary part of <exp[-i j tau H]>
    for dft_order in dft_order_sample:
        real_sample.append(quantum_circuits.measure_Xj_1qubit(input_state_vector, hamiltonian, dft_order, energy_rescalor))
        imag_sample.append(quantum_circuits.measure_Yj_1qubit(input_state_vector, hamiltonian, dft_order, energy_rescalor))

    real_sample = np.asarray(real_sample)
    real_sample = np.asarray(real_sample)
    expiH_sample = real_sample + 1.0j * imag_sample

    return expiH_sample


def eval_acdf_single_sample(energy_grids, j_val, Zj, angle_j):
    """
    Evaluate the G_function at points stored in x - energy grids.
    G = F_tot * (Xj + iYj) * exp[i (ang_j + j * x)]
    Args:
        energy_grids - points at which the G function is evaluated.
        F_tot - sum of the norms of DFT coeffs of the approximate Heaviside function.
        j_val - int
        Zj -  a complex number that can be (+- 1 +- 1j)
        angle_j - a number (angle)
    Returns:
        1D array of the size of x.
    """
    G = Zj * np.exp(1.0j * (angle_j + j_val * energy_grids))
    return G


def acdf_kernel(max_dft_order, Fj, j_sample, Z_sample, energy_grid=None, nmesh=200):
    """
    Evaluate ACDF given Fj, j_sample, Z_sample
    Args:
        max_dft_order - cutoff of the DFT expansion (d in the paper)
        Fj - Fourier transforms of the approximate Heaviside function
        j_sample - a sample of integers in [-max_dft_order, max_dft_order], generated by classical sampling
        Z_sample - a sample of complex numbers in {+-1 +- 1.j}, generated by the quantum computer
        energy_grid - points where the function is evaluated
        nmesh - number of grids to generate a mesh of real space points
    Returns:
        An array containing the values of the approximate CDF at points in energy_grid.
    """
    # TODO rewrite the test

    num_samples = len(j_sample)
    Fj_angle = np.angle(Fj)
    # generate G
    if energy_grid is None:
        energy_grid = np.linspace(-np.pi, np.pi, nmesh, endpoint=True)
    try:
        num_grid = energy_grid.shape[-1]
        G_sample = np.zeros(num_grid, dtype=np.complex)
    except:
        num_grid = 1
        G_sample = 0.0

    for i in range(num_samples):
        j, Zj = j_sample[i], Z_sample[i]
        ang_j = Fj_angle[j + max_dft_order]
        G = eval_acdf_single_sample(energy_grid, j, Zj, ang_j)
        G_sample += G

    Fj_abs = np.abs(Fj)
    F_tot = np.sum(Fj_abs)

    G_sample = G_sample * F_tot / num_samples

    return G_sample
