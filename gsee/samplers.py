# generating classical and quantum samples

import numpy as np
from gsee import helpers
from gsee import quantum_circuits


def dft_order_sampler(num_samples, max_dft_order, dft_coeffs):
    """
    Generate the dft orders from [-max_dft_order, max_dft_order]
    Args:
        num_samples    : number of samples
        max_dft_order  : cutoff of the DFT expansion (d in the paper)
        dft_coeffs     : complex numbers of the DFT coefficients
    Returns: 
        dft_orders_sample   : an array of integers of size num_samples.
    """
    abs_dft_coeffs = np.abs(dft_coeffs)
    weights = abs_dft_coeffs / np.sum(abs_dft_coeffs)

    dft_order_range = np.arange(-max_dft_order, max_dft_order+1, 1)
    # generate random j values
    dft_orders_sample = np.random.choice(dft_order_range, size=num_samples, p=weights)

    return dft_orders_sample


def hamiltonian_evolutor_sampler(dft_orders_sample, input_state_vector, hamiltonian, energy_rescalor=None, spectrum_bound=np.pi/3):
    """
    Sampling <exp[-i j tau H]>.
    Args:
        dft_orders_sample : a sample of integers in [-max_dft_order, max_dft_order], generated by classical sampling
        input_state_vector: initial state
        hamiltonian       : Hamiltonian
        energy_rescalor   : rescaling factor of the Hamiltonian (tau in the paper)
    Returns:
        expiH_sample - array of complex numbers, set of (XJ + iYJ) values.
    """

    if energy_rescalor is None:
        energy_rescalor = quantum_circuits.rescale_hamiltonian_spectrum(hamiltonian, bound=spectrum_bound)
    # generate Xj and Yj values
    real_sample = [] # real part of <exp[-i j tau H]>
    imag_sample = [] # imaginary part of <exp[-i j tau H]>
    for dft_order in dft_orders_sample:
        real_sample.append(quantum_circuits.measure_Xj_1qubit(input_state_vector, hamiltonian, dft_order, energy_rescalor))
        imag_sample.append(quantum_circuits.measure_Yj_1qubit(input_state_vector, hamiltonian, dft_order, energy_rescalor))

    real_sample = np.asarray(real_sample)
    real_sample = np.asarray(real_sample)
    expiH_sample = real_sample + 1.0j * imag_sample

    return expiH_sample